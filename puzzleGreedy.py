# -*- coding: utf-8 -*-
"""greedyFix

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18x7pGyVF32y1yo98BErBw2QAPf2s2xMb
"""

class Node:
    def __init__(self,data,level,hval):
        self.data = data
        self.level = level
        self.hval = hval

    def generate_child(self):
        x,y = self.find_zero(self.data,0)
        #possible moves
        val_list = [[x,y-1],[x,y+1],[x-1,y],[x+1,y]]
        children = []
        for i in val_list:
            child = self.swap(self.data,x,y,i[0],i[1])
            if child is not None:
                child_node = Node(child,self.level+1,0)
                children.append(child_node)
        return children
        
    def swap(self,puz,x1,y1,x2,y2):
      if x2 >= 0 and x2 < len(self.data) and y2 >= 0 and y2 < len(self.data):
            temp_puz = []
            temp_puz = self.copy(puz)
            temp = temp_puz[x2][y2]
            temp_puz[x2][y2] = temp_puz[x1][y1]
            temp_puz[x1][y1] = temp
            return temp_puz
      else:
            return None
            
    #copy nodes
    def copy(self,root):
        temp = []
        for i in root:
            t = []
            for j in i:
                t.append(j)
            temp.append(t)
        return temp    

    #cari 0        
    def find_zero(self,puz,x):
        for i in range(0,len(self.data)):
            for j in range(0,len(self.data)):
                if puz[i][j] == x:
                    return i,j


class Puzzle:
    def __init__(self,size,goal):
        #puzzle's size, start-goal
        self.n = size
        self.open = []
        self.closed = []
        self.goals=goal

    def inputs(self):
        parent = []
        for i in range(0,self.n):
            temp = list(input())
            parent.append(temp)
        return parent

    def h(self,start,goal):
        #heuristic function--manhattan distance
        dist = 0
        for i in range(len(start)):
            for j in range(len(start[i])):
              for x in range(len(goal)):
                for y in range(len(goal[x])):
                 if start[i][j] == goal[x][y]:
                    dist += abs(x-i)+abs(y-j)
                 if start[i][j]==0 and goal[x][y]==0:
                    break
                 elif start[i][j]!=goal[x][y]:
                    continue
        return dist
        

     def solve(self):
       #input start dan goal
        print("Enter puzzle's start state\n")
        start = self.inputs()
        print("Enter puzzle's goal state\n")        
        goal = self.inputs()

        start_node = Node(start,goal,0,0)
        start_node.hval = self.h(start,goal)
        self.open.append(start_node)
        print("\n")
        #solution
        while True:
            cur = self.open[0]
            print("-----")
            for i in cur.data:
                for j in i:
                    print(j,end=" ")
                print("")
           # apabila nilai heuristic state puzzle adalah 0-> sudah mencapai goal
            if(self.h(cur.data,goal) == 0):
                break
            for i in cur.generate_child():
                i.hval = self.h(i,goal)
                self.open.append(i)
            self.closed.append(cur)
            del self.open[0]

            #sort berdasarkan nilai heuristic terkecil
            self.open.sort(key = lambda x:x.hval,reverse=False)


puz = Puzzle(3)
puz.solve()